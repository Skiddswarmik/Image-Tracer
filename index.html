<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Camera Overlay Editor</title>

<style>
* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  touch-action: none;
}

video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

video.flipped {
  transform: scaleX(-1);
}

/* Overlay */
#overlay {
  position: absolute;
  display: none;
  touch-action: none;
  top: 50%;
  left: 50%;
  transform-origin: center center;
  cursor: move;
}

#overlayImg {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 4px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  pointer-events: none;
}

/* Active state for overlay */
#overlay.active {
  outline: 2px solid rgba(255,255,255,0.5);
  outline-offset: 4px;
}

/* Corner resize handles */
.resize-handle {
  position: absolute;
  width: 20px;
  height: 20px;
  background: #4A9EFF;
  border: 2px solid white;
  border-radius: 50%;
  z-index: 10;
  cursor: nwse-resize;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.resize-handle.tl {
  top: -10px;
  left: -10px;
  cursor: nwse-resize;
}

.resize-handle.tr {
  top: -10px;
  right: -10px;
  cursor: nesw-resize;
}

.resize-handle.bl {
  bottom: -10px;
  left: -10px;
  cursor: nesw-resize;
}

.resize-handle.br {
  bottom: -10px;
  right: -10px;
  cursor: nwse-resize;
}

/* Control panels */
.control-panel {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(20, 20, 20, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  color: #fff;
  z-index: 9999;
  font-size: 15px;
  max-width: 90vw;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
}

.panel-header {
  padding: 14px 20px;
  font-weight: 600;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.panel-toggle {
  font-size: 12px;
  opacity: 0.7;
  transition: transform 0.2s;
}

.panel-toggle.open {
  transform: rotate(180deg);
}

.panel-body {
  display: none;
  padding: 16px 20px;
  gap: 16px;
  flex-direction: column;
}

.panel-body.open {
  display: flex;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.control-row {
  display: flex;
  align-items: center;
  gap: 12px;
  min-height: 36px;
}

label {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  user-select: none;
  flex: 1;
}

input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: #4A9EFF;
}

input[type="range"] {
  flex: 1;
  height: 6px;
  border-radius: 3px;
  background: rgba(255,255,255,0.2);
  outline: none;
  cursor: pointer;
  accent-color: #4A9EFF;
}

input[type="color"] {
  width: 44px;
  height: 36px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  background: none;
}

.upload-btn {
  background: #4A9EFF;
  color: white;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  text-align: center;
  font-weight: 500;
  transition: background 0.2s;
}

.upload-btn:active {
  background: #3A8EEF;
}

.slider-group {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
}

.slider-label {
  min-width: 80px;
  font-size: 14px;
  opacity: 0.9;
}

.slider-value {
  min-width: 40px;
  text-align: right;
  font-size: 14px;
  opacity: 0.7;
}

#cameraPanel {
  bottom: 16px;
}

#photoPanel {
  bottom: 100px;
}

.divider {
  height: 1px;
  background: rgba(255,255,255,0.1);
  margin: 4px 0;
}
</style>
</head>

<body>
<div id="container">
  <video id="camera" autoplay playsinline></video>

  <div id="overlay">
    <canvas id="overlayImg"></canvas>
    <div class="resize-handle tl"></div>
    <div class="resize-handle tr"></div>
    <div class="resize-handle bl"></div>
    <div class="resize-handle br"></div>
  </div>
</div>

<!-- Photo Panel -->
<div class="control-panel" id="photoPanel">
  <div class="panel-header" id="photoHeader">
    <span>Photo Overlay</span>
    <span class="panel-toggle" id="photoToggle">▼</span>
  </div>
  <div class="panel-body" id="photoBody">
    <label class="upload-btn">
      Upload Image
      <input type="file" id="imageUpload" accept="image/*" style="display:none">
    </label>

    <div class="divider"></div>

    <div class="slider-group">
      <span class="slider-label">Opacity</span>
      <input type="range" id="opacitySlider" min="0" max="100" value="100">
      <span class="slider-value" id="opacityValue">100%</span>
    </div>

    <div class="control-row">
      <label><input type="checkbox" id="flipOverlay"> Flip Horizontal</label>
    </div>

    <div class="divider"></div>

    <div class="control-row">
      <label><input type="checkbox" id="removeColor"> Remove Background</label>
    </div>

    <div class="slider-group">
      <span class="slider-label">Key Color</span>
      <input type="color" id="keyColor" value="#00ff00">
    </div>

    <div class="slider-group">
      <span class="slider-label">Tolerance</span>
      <input type="range" id="tolerance" min="0" max="100" value="30">
      <span class="slider-value" id="toleranceValue">30</span>
    </div>
  </div>
</div>

<!-- Camera Panel -->
<div class="control-panel" id="cameraPanel">
  <div class="panel-header" id="cameraHeader">
    <span>Camera Controls</span>
    <span class="panel-toggle" id="cameraToggle">▼</span>
  </div>
  <div class="panel-body" id="cameraBody">
    <div class="control-row">
      <label>
        <span style="min-width: 100px;">Camera</span>
        <select id="cameraSelect" style="flex: 1; padding: 8px 12px; border-radius: 6px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); cursor: pointer; font-size: 14px;">
          <option value="loading">Loading cameras...</option>
        </select>
      </label>
    </div>
    <div class="control-row">
      <label><input type="checkbox" id="flipCamera"> Flip Camera View</label>
    </div>
  </div>
</div>

<script>
/************************************
  PANEL TOGGLE
*************************************/
function setupPanel(headerId, toggleId, bodyId) {
  const header = document.getElementById(headerId);
  const toggle = document.getElementById(toggleId);
  const body = document.getElementById(bodyId);
  
  header.addEventListener("click", () => {
    const isOpen = body.classList.contains("open");
    body.classList.toggle("open");
    toggle.classList.toggle("open");
  });
}

setupPanel("cameraHeader", "cameraToggle", "cameraBody");
setupPanel("photoHeader", "photoToggle", "photoBody");

/************************************
  ELEMENTS
*************************************/
const camera = document.getElementById("camera");
const overlay = document.getElementById("overlay");
const overlayCanvas = document.getElementById("overlayImg");
const ctx = overlayCanvas.getContext("2d", { willReadFrequently: true });
const imageUpload = document.getElementById("imageUpload");
const opacitySlider = document.getElementById("opacitySlider");
const opacityValue = document.getElementById("opacityValue");
const flipOverlay = document.getElementById("flipOverlay");
const flipCamera = document.getElementById("flipCamera");
const cameraSelect = document.getElementById("cameraSelect");
const removeColor = document.getElementById("removeColor");
const keyColor = document.getElementById("keyColor");
const tolerance = document.getElementById("tolerance");
const toleranceValue = document.getElementById("toleranceValue");

let originalImage = null;

/************************************
  CAMERA — ENUMERATE & SELECT
*************************************/
let currentStream = null;
let availableCameras = [];

async function enumerateCameras() {
  try {
    // First request camera permission
    const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
    tempStream.getTracks().forEach(track => track.stop());
    
    // Now enumerate devices
    const devices = await navigator.mediaDevices.enumerateDevices();
    availableCameras = devices.filter(device => device.kind === 'videoinput');
    
    // Populate dropdown
    cameraSelect.innerHTML = '';
    availableCameras.forEach((camera, index) => {
      const option = document.createElement('option');
      option.value = camera.deviceId;
      
      // Create friendly labels
      let label = camera.label || `Camera ${index + 1}`;
      
      // Simplify common labels
      if (label.includes('back') || label.includes('rear')) {
        label = label.includes('wide') ? 'Back Wide' : 
                label.includes('ultra') ? 'Back Ultra Wide' :
                label.includes('tele') ? 'Back Telephoto' : 'Back Camera';
      } else if (label.includes('front') || label.includes('face')) {
        label = 'Front Camera';
      }
      
      option.textContent = label;
      cameraSelect.appendChild(option);
    });
    
    // Select rear camera by default (prefer main back camera)
    const rearCamera = availableCameras.find(cam => 
      cam.label.toLowerCase().includes('back') && 
      !cam.label.toLowerCase().includes('ultra') &&
      !cam.label.toLowerCase().includes('wide')
    ) || availableCameras.find(cam => 
      cam.label.toLowerCase().includes('back') ||
      cam.label.toLowerCase().includes('rear') ||
      cam.label.toLowerCase().includes('environment')
    ) || availableCameras[0];
    
    if (rearCamera) {
      cameraSelect.value = rearCamera.deviceId;
      await startCamera(rearCamera.deviceId);
    }
    
  } catch (err) {
    console.error("Error enumerating cameras:", err);
    cameraSelect.innerHTML = '<option>Camera access denied</option>';
  }
}

async function startCamera(deviceId) {
  if (currentStream) {
    currentStream.getTracks().forEach(track => track.stop());
  }

  const constraints = {
    video: {
      deviceId: deviceId ? { exact: deviceId } : undefined,
      width: { ideal: 1920 },
      height: { ideal: 1080 }
    }
  };

  try {
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    camera.srcObject = currentStream;
    
    // Check if this is a front camera for auto-flip
    const currentCamera = availableCameras.find(cam => cam.deviceId === deviceId);
    const isFrontCamera = currentCamera && 
      (currentCamera.label.toLowerCase().includes('front') || 
       currentCamera.label.toLowerCase().includes('face') ||
       currentCamera.label.toLowerCase().includes('user'));
    
    camera.classList.toggle("flipped", isFrontCamera && !flipCamera.checked);
  } catch (err) {
    console.error("Camera error:", err);
  }
}

// Initialize cameras
enumerateCameras();

// Handle camera selection
cameraSelect.addEventListener("change", e => {
  startCamera(e.target.value);
});

flipCamera.addEventListener("change", () => {
  camera.classList.toggle("flipped");
});

/************************************
  OVERLAY TRANSFORM STATE
*************************************/
let overlayState = {
  x: 0,
  y: 0,
  width: 300,
  height: 300,
  rotation: 0
};

let interactionState = {
  mode: null, // 'drag', 'resize', 'pinch'
  startX: 0,
  startY: 0,
  startWidth: 0,
  startHeight: 0,
  startOverlayX: 0,
  startOverlayY: 0,
  resizeHandle: null,
  initialPinchDistance: 0,
  initialPinchAngle: 0,
  initialPinchRotation: 0,
  initialPinchWidth: 0,
  initialPinchHeight: 0
};

/************************************
  MOUSE INTERACTIONS
*************************************/
// Mouse drag on overlay
overlay.addEventListener("mousedown", e => {
  if (e.target.classList.contains('resize-handle')) return;
  e.preventDefault();
  
  interactionState.mode = 'drag';
  interactionState.startX = e.clientX;
  interactionState.startY = e.clientY;
  interactionState.startOverlayX = overlayState.x;
  interactionState.startOverlayY = overlayState.y;
  
  overlay.classList.add("active");
});

// Mouse resize on handles
document.querySelectorAll('.resize-handle').forEach(handle => {
  handle.addEventListener('mousedown', e => {
    e.preventDefault();
    e.stopPropagation();
    
    interactionState.mode = 'resize';
    interactionState.resizeHandle = handle.classList.contains('tl') ? 'tl' :
                                    handle.classList.contains('tr') ? 'tr' :
                                    handle.classList.contains('bl') ? 'bl' : 'br';
    interactionState.startX = e.clientX;
    interactionState.startY = e.clientY;
    interactionState.startWidth = overlayState.width;
    interactionState.startHeight = overlayState.height;
    interactionState.startOverlayX = overlayState.x;
    interactionState.startOverlayY = overlayState.y;
    
    overlay.classList.add("active");
  });
});

document.addEventListener("mousemove", e => {
  if (!interactionState.mode) return;
  e.preventDefault();
  
  if (interactionState.mode === 'drag') {
    const deltaX = e.clientX - interactionState.startX;
    const deltaY = e.clientY - interactionState.startY;
    
    overlayState.x = interactionState.startOverlayX + deltaX;
    overlayState.y = interactionState.startOverlayY + deltaY;
    
    updateOverlayTransform();
  } else if (interactionState.mode === 'resize') {
    const deltaX = e.clientX - interactionState.startX;
    const deltaY = e.clientY - interactionState.startY;
    
    let newWidth = interactionState.startWidth;
    let newHeight = interactionState.startHeight;
    let offsetX = 0;
    let offsetY = 0;
    
    // Calculate size change based on which handle
    if (interactionState.resizeHandle === 'br') {
      newWidth += deltaX;
      newHeight += deltaY;
    } else if (interactionState.resizeHandle === 'bl') {
      newWidth -= deltaX;
      newHeight += deltaY;
      offsetX = deltaX;
    } else if (interactionState.resizeHandle === 'tr') {
      newWidth += deltaX;
      newHeight -= deltaY;
      offsetY = deltaY;
    } else if (interactionState.resizeHandle === 'tl') {
      newWidth -= deltaX;
      newHeight -= deltaY;
      offsetX = deltaX;
      offsetY = deltaY;
    }
    
    // Enforce minimum size
    if (newWidth < 50) {
      newWidth = 50;
      offsetX = 0;
    }
    if (newHeight < 50) {
      newHeight = 50;
      offsetY = 0;
    }
    
    overlayState.width = newWidth;
    overlayState.height = newHeight;
    overlayState.x = interactionState.startOverlayX + offsetX;
    overlayState.y = interactionState.startOverlayY + offsetY;
    
    updateOverlayTransform();
  }
});

document.addEventListener("mouseup", () => {
  if (interactionState.mode) {
    interactionState.mode = null;
    overlay.classList.remove("active");
  }
});

/************************************
  TOUCH INTERACTIONS
*************************************/
overlay.addEventListener("touchstart", e => {
  if (!overlay.style.display || overlay.style.display === "none") return;
  e.preventDefault();
  e.stopPropagation();

  overlay.classList.add("active");

  if (e.touches.length === 1) {
    // Check if touching a handle
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (target && target.classList.contains('resize-handle')) {
      interactionState.mode = 'resize';
      interactionState.resizeHandle = target.classList.contains('tl') ? 'tl' :
                                      target.classList.contains('tr') ? 'tr' :
                                      target.classList.contains('bl') ? 'bl' : 'br';
      interactionState.startX = touch.clientX;
      interactionState.startY = touch.clientY;
      interactionState.startWidth = overlayState.width;
      interactionState.startHeight = overlayState.height;
      interactionState.startOverlayX = overlayState.x;
      interactionState.startOverlayY = overlayState.y;
    } else {
      // Regular drag
      interactionState.mode = 'drag';
      interactionState.startX = touch.clientX;
      interactionState.startY = touch.clientY;
      interactionState.startOverlayX = overlayState.x;
      interactionState.startOverlayY = overlayState.y;
    }
  } else if (e.touches.length === 2) {
    // Two-finger pinch
    interactionState.mode = 'pinch';
    
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    
    interactionState.initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
    interactionState.initialPinchAngle = Math.atan2(dy, dx) * 180 / Math.PI;
    interactionState.initialPinchRotation = overlayState.rotation;
    interactionState.initialPinchWidth = overlayState.width;
    interactionState.initialPinchHeight = overlayState.height;
  }
});

overlay.addEventListener("touchmove", e => {
  if (!overlay.style.display || overlay.style.display === "none") return;
  e.preventDefault();
  e.stopPropagation();

  if (e.touches.length === 1 && interactionState.mode === 'drag') {
    const touch = e.touches[0];
    const deltaX = touch.clientX - interactionState.startX;
    const deltaY = touch.clientY - interactionState.startY;
    
    overlayState.x = interactionState.startOverlayX + deltaX;
    overlayState.y = interactionState.startOverlayY + deltaY;
    
    updateOverlayTransform();
  } else if (e.touches.length === 1 && interactionState.mode === 'resize') {
    const touch = e.touches[0];
    const deltaX = touch.clientX - interactionState.startX;
    const deltaY = touch.clientY - interactionState.startY;
    
    let newWidth = interactionState.startWidth;
    let newHeight = interactionState.startHeight;
    let offsetX = 0;
    let offsetY = 0;
    
    if (interactionState.resizeHandle === 'br') {
      newWidth += deltaX;
      newHeight += deltaY;
    } else if (interactionState.resizeHandle === 'bl') {
      newWidth -= deltaX;
      newHeight += deltaY;
      offsetX = deltaX;
    } else if (interactionState.resizeHandle === 'tr') {
      newWidth += deltaX;
      newHeight -= deltaY;
      offsetY = deltaY;
    } else if (interactionState.resizeHandle === 'tl') {
      newWidth -= deltaX;
      newHeight -= deltaY;
      offsetX = deltaX;
      offsetY = deltaY;
    }
    
    if (newWidth < 50) {
      newWidth = 50;
      offsetX = 0;
    }
    if (newHeight < 50) {
      newHeight = 50;
      offsetY = 0;
    }
    
    overlayState.width = newWidth;
    overlayState.height = newHeight;
    overlayState.x = interactionState.startOverlayX + offsetX;
    overlayState.y = interactionState.startOverlayY + offsetY;
    
    updateOverlayTransform();
  } else if (e.touches.length === 2 && interactionState.mode === 'pinch') {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    // Scale based on pinch
    const scaleFactor = distance / interactionState.initialPinchDistance;
    overlayState.width = interactionState.initialPinchWidth * scaleFactor;
    overlayState.height = interactionState.initialPinchHeight * scaleFactor;
    
    // Rotate based on angle change
    const angleDelta = angle - interactionState.initialPinchAngle;
    overlayState.rotation = interactionState.initialPinchRotation + angleDelta;
    
    updateOverlayTransform();
  }
});

overlay.addEventListener("touchend", e => {
  e.preventDefault();
  
  if (e.touches.length === 0) {
    interactionState.mode = null;
    overlay.classList.remove("active");
  } else if (e.touches.length === 1 && interactionState.mode === 'pinch') {
    // Transition from pinch to drag
    interactionState.mode = 'drag';
    interactionState.startX = e.touches[0].clientX;
    interactionState.startY = e.touches[0].clientY;
    interactionState.startOverlayX = overlayState.x;
    interactionState.startOverlayY = overlayState.y;
  }
});

/************************************
  MOUSE WHEEL (DESKTOP)
*************************************/
overlay.addEventListener("wheel", e => {
  e.preventDefault();
  
  if (e.shiftKey) {
    overlayState.rotation += e.deltaY < 0 ? 5 : -5;
  } else {
    const scaleFactor = e.deltaY < 0 ? 1.05 : 0.95;
    overlayState.width *= scaleFactor;
    overlayState.height *= scaleFactor;
  }
  
  updateOverlayTransform();
});

/************************************
  UPDATE TRANSFORM
*************************************/
function updateOverlayTransform() {
  const flipX = flipOverlay.checked ? -1 : 1;
  overlay.style.width = overlayState.width + 'px';
  overlay.style.height = overlayState.height + 'px';
  overlay.style.transform = `translate(${overlayState.x}px, ${overlayState.y}px) scaleX(${flipX}) rotate(${overlayState.rotation}deg)`;
}

/************************************
  OPACITY SLIDER
*************************************/
opacitySlider.addEventListener("input", () => {
  const value = opacitySlider.value;
  overlay.style.opacity = value / 100;
  opacityValue.textContent = value + "%";
});

/************************************
  TOLERANCE SLIDER
*************************************/
tolerance.addEventListener("input", () => {
  toleranceValue.textContent = tolerance.value;
  if (removeColor.checked && originalImage) {
    applyChromaKey();
  }
});

/************************************
  FLIP OVERLAY
*************************************/
flipOverlay.addEventListener("change", () => {
  updateOverlayTransform();
});

/************************************
  CHROMA KEY (BACKGROUND REMOVAL)
*************************************/
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

function applyChromaKey() {
  if (!originalImage) return;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = originalImage.width;
  tempCanvas.height = originalImage.height;
  const tempCtx = tempCanvas.getContext('2d');
  
  tempCtx.drawImage(originalImage, 0, 0);
  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const data = imageData.data;
  
  const keyRgb = hexToRgb(keyColor.value);
  const threshold = parseInt(tolerance.value) * 2.55; // Convert 0-100 to 0-255
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const diff = Math.sqrt(
      Math.pow(r - keyRgb.r, 2) +
      Math.pow(g - keyRgb.g, 2) +
      Math.pow(b - keyRgb.b, 2)
    );
    
    if (diff < threshold) {
      data[i + 3] = 0; // Make transparent
    }
  }
  
  tempCtx.putImageData(imageData, 0, 0);
  
  overlayCanvas.width = tempCanvas.width;
  overlayCanvas.height = tempCanvas.height;
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  ctx.drawImage(tempCanvas, 0, 0);
}

function renderOriginalImage() {
  if (!originalImage) return;
  
  overlayCanvas.width = originalImage.width;
  overlayCanvas.height = originalImage.height;
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  ctx.drawImage(originalImage, 0, 0);
}

/************************************
  REMOVE COLOR TOGGLE
*************************************/
removeColor.addEventListener("change", () => {
  if (removeColor.checked) {
    applyChromaKey();
  } else {
    renderOriginalImage();
  }
});

keyColor.addEventListener("input", () => {
  if (removeColor.checked && originalImage) {
    applyChromaKey();
  }
});

/************************************
  IMAGE UPLOAD
*************************************/
imageUpload.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = evt => {
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      
      // Set initial size (max 400px)
      const maxSize = 400;
      const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
      overlayCanvas.width = img.width;
      overlayCanvas.height = img.height;
      
      // Reset state
      overlayState.width = img.width * scale;
      overlayState.height = img.height * scale;
      overlayState.x = 0;
      overlayState.y = 0;
      overlayState.rotation = 0;
      
      if (removeColor.checked) {
        applyChromaKey();
      } else {
        renderOriginalImage();
      }
      
      overlay.style.display = "block";
      updateOverlayTransform();
    };
    img.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});
</script>
</body>
</html>
